#lang racket

;; =============================================================================
;; 1. Configuration Structures
;; =============================================================================

;; Represents a single cache level
(struct cache-config (name sets ways lat next-type) #:transparent)

;; Represents a full experiment/test case
(struct experiment (name configs) #:transparent)

;; =============================================================================
;; 2. Configuration Definitions (The "Input")
;; =============================================================================

;; Case 001: Standard 3-Level Hierarchy
(define case-001
  (experiment "case_001"
              (list (cache-config "L1" 64 8 4 "L2")
                    (cache-config "L2" 512 8 64 "L3")
                    (cache-config "L3" 8192 16 64 "MainMemory"))))

;; Case 002: L1/L2 Only (Faster simulation)
(define case-002
  (experiment "case_002"
              (list (cache-config "L1" 64 8 4 "L2")
                    (cache-config "L2" 512 8 64 "MainMemory"))))

(define all-experiments (list case-001 case-002))

;; =============================================================================
;; 3. C++ Code Generation Logic
;; =============================================================================

;; Generates the `using L1Type = ...` line for a single cache config.
;; The `next-type` provided in the list is the "key" to link to the next level.
;; However, the C++ needs the *type alias* (e.g. L2Type/MemType), not just string "L2".
;; We handle this mapping:
;; - "MainMemory" -> "MemType"
;; - "L3" -> "L3Type"
;; - etc.
(define (get-cpp-type-alias type_name)
  (if (equal? type_name "MainMemory")
      "MemType"
      (format "~aType" type_name)))

(define (generate-single-cache-def config)
  (format "  using ~aType = Cache<\"~a\", ~a, ~a, ~a, 64, LRUPolicy, ~a>;\n"
          (cache-config-name config)
          (cache-config-name config)
          (get-cpp-type-alias (cache-config-next-type config))
          (cache-config-sets config)
          (cache-config-ways config)
          (cache-config-lat config)))

;; Generates the full `main()` implementation for a given experiment
(define (generate-cpp-content exp)
  (define configs (experiment-configs exp))

  ;; Reverse the configs so we print dependencies first (L3 before L2)
  (define reversed-configs (reverse configs))

  (define cache-definitions
    (string-append
     "  using MemType = MainMemory<\"MainMemory\">;\n"
     (apply string-append (map generate-single-cache-def reversed-configs))))

  ;; The top-level cache name (e.g., L1) is the first in the original list
  (define top-level-type (format "~aType" (cache-config-name (first configs))))

  (format #<<EOF
#include <string>
#include <vector>

#include "stratum/cache_sim.hpp"
#include "stratum/simulation.hpp"

using namespace stratum;

// Generated by Racket
int main() {
  // Define Cache Types
~a
  // Define Hierarchy for Stats / Verification
  std::vector<std::string> hierarchy = { "L1", "L2", "L3", "MainMemory" }; // Simplification: Hardcoded for now, ideally generated too

  // Define Traces
  const std::string project_root = STRATUM_ROOT;
  std::vector<std::pair<std::string, std::string>> traces = {
      {"Sequential", project_root + "/test/data/sequential.txt"},
      {"Random", project_root + "/test/data/random.txt"},
      {"Temporal", project_root + "/test/data/temporal.txt"},
      {"Spatial", project_root + "/test/data/spatial.txt"},
      {"LargeLoop", project_root + "/test/data/largeloop.txt"},
      {"Gaussian", project_root + "/test/data/gaussian.txt"}};

  // Run Simulations
  for (const auto& t : traces) {
    RunTraceSimulation<~a>(t.first, t.second, hierarchy);
  }

  return 0;
}
EOF
          cache-definitions
          top-level-type))

;; =============================================================================
;; 4. CMake Generation Logic
;; =============================================================================

(define (generate-cmake-content experiments)
  (define targets
    (for/list ([exp experiments])
      (define name (experiment-name exp))
      (format #<<EOF
add_executable(~a ~a.cpp)
target_link_libraries(~a PRIVATE fmt::fmt)
target_compile_definitions(~a PRIVATE STRATUM_ROOT="${CMAKE_SOURCE_DIR}")

EOF
              name name name name)))

  (string-append
   "# Generated by Racket\n\n"
   (apply string-append targets)))

;; =============================================================================
;; 5. Main Execution / File I/O
;; =============================================================================

;; Get output directory from command-line argument or use default
(define output-dir
  (let ([args (current-command-line-arguments)])
    (if (> (vector-length args) 0)
        (vector-ref args 0)
        "build/generated")))

(displayln (format "Output directory: ~a" output-dir))

;; Ensure directory exists (create parent directories if needed)
(unless (directory-exists? output-dir)
  (make-directory* output-dir))

;; Write each C++ file
(for ([exp all-experiments])
  (define filename (build-path output-dir (format "~a.cpp" (experiment-name exp))))
  (displayln (format "Generating ~a..." filename))
  (call-with-output-file filename
    (lambda (out) (display (generate-cpp-content exp) out))
    #:exists 'replace))

;; Write CMakeLists.txt
(define cmake-filename (build-path output-dir "CMakeLists.txt"))
(displayln (format "Generating ~a..." cmake-filename))
(call-with-output-file cmake-filename
  (lambda (out) (display (generate-cmake-content all-experiments) out))
  #:exists 'replace)

(displayln "Done!")
